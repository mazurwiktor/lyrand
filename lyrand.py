import argparse
import csv
import json
import multiprocessing
import plyr

from generate import line_per_track


def csv2list(path):
    with open(path) as f:
        reader = csv.reader(f)
        next(reader, None)  # drop header
        return [(r[2], r[1]) for r in reader]


def fetch_lyrics(artist, title):
    query = plyr.Query(artist=artist, title=title, get_type="lyrics")
    items = query.commit()
    if not items:
        print("ERROR: {} - {} has no lyrics".format(artist, title))
        return None
    decoded = items[0].data.decode("utf-8")
    if decoded == "Instrumental":
        print("{} - {} is instrumental".format(artist, title))
        return None
    return decoded


def fetch_lyrics_worker(artist, title, storage):
    lyrics = fetch_lyrics(artist, title)
    if lyrics:
        storage.append((artist, title, lyrics))


def sanitize(txt):
    return txt.split("-")[0]


def download(paths_in, path_out):
    def flatten(l):
        return [item for sublist in l for item in sublist]

    tracks = [csv2list(path) for path in paths_in]

    manager = multiprocessing.Manager()
    lyrics = manager.list()

    processes = []

    for artist, title in flatten(tracks):
        p = multiprocessing.Process(target=fetch_lyrics_worker, args=(artist, title, lyrics))
        processes.append(p)
        p.start()

    for p in processes:
        p.join()

    if path_out:
        with open(path_out, "w") as f:
            json.dump(list(lyrics), f)
    else:
        print(json.dumps(list(lyrics), indent=2))


def generate(path_in, path_out, max_lines):
    with open(path_in) as f:
        data = json.load(f)
        tracks = [t[2] for t in data]
        for line in line_per_track(tracks, max_lines):
            print(line)


def get_args():
    pp = argparse.ArgumentParser(add_help=False)
    ap = argparse.ArgumentParser(description="generate random lyrics out of given titles")
    sp = ap.add_subparsers(title="subcommands", dest="subcommand")
    sp.required = True

    sp_download = sp.add_parser("download", help="download and store lyrics", parents=[pp])
    sp_download.add_argument("input", help="paths to csv files generated by Exportify", nargs="+")
    sp_download.add_argument("-o", "--output", help="path to .json file to be dumped")

    sp_generate = sp.add_parser("generate", help="generate lyrics", parents=[pp])
    sp_generate.add_argument("input", help="path to json dump with downloaded lyrics")
    sp_generate.add_argument("-o", "--output", help="path to .txt file to dump the result")
    sp_generate.add_argument("--max-lines", help="max length of output record", type=int)

    return ap.parse_args()


def main():
    args = get_args()
    if args.subcommand == "download":
        download(args.input, args.output)
    elif args.subcommand == "generate":
        generate(args.input, args.output, args.max_lines)


if __name__ == "__main__":
    main()
